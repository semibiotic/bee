13.08.2000 Добавлено _описание_ особенностей печати через несколько объектов 
           WINOUT

                          Оконный класс WINOUT
			  
  WINOUT - класс вывода текста в прямоугольное окно, с заворачиванием. В
качестве печати низкого уровня используются процедуры UNICON.

                               Поля класса
  int lin,col
Координаты начала окна (абсолютные). Допускаются заэкранные (т.е. отрицательные,
или большие пределов экрана; ума не приложу, зачем можно использовать последние)
значения. 
  После прямых манипуляций с этими полями необходимо вызвать at().

  int lins,cols
Размеры окна. Допускаются размеры большие размеров экрана терминала.

  int wlin,wcol
Текущие координаты внутри окна. Важно понимать, что эти координаты лишь
предполагаемые координаты курсора, и они соответствуют реальным только
непосредственно после позиционирования (методом at()) и далее при печати
через класc. Методы класса обрабатывают управляющие коды '\n' '\t'. Иные
коды применять не стоит (т.к. текущие координаты окажутся недействительными).
Отрицательные эначения и значения вне пределов lins и cols нежелательны (хотя
всегда пожалуйста, если этому будет смысл).

  int fAt
Внутренний флаг. Говорит о том, что последнее позиционирование было отменено
из-за того, что результирующие координаты находились за экраном и процедура
вывода символа (после этого "вывода") должна будет вызвать at().

                              Методы класса

   void   New	(void * templ)
Устанавливает (импортирует) новые координаты и размеры окна из класса, на
который указывает аргумент, а также производит позиционирование в координаты
(0,0). Значение аргумента трактуется, как поинтер на класс шаблона окна
winTEMPL:
                  class winTEMPL
                  {  public:
                     int  lin;
                     int  col;
                     int  lins;
                     int  cols;
                  };
  На самом деле объектов класса winTEMPL не существует, зато в качестве
поинтера на него, можно эффективно использовать поинтеры на все классы данной
программы, описывающие окно - AREA, DIALOG, CONTROL и, собственно, класс WINOUT.
  Таким образом методом New() можно переключать контекст данного объекта WINOUT
на тот или иной оконный объект, за исключением объекта CONTROL (т.к. он
использует относительные координаты). Нужно сначала переключить контектс на
родительский диалог (диалог переключает Defs на свой контекст), а потом
импортировать относительные координаты (методом RelNew()) из целевого объекта
CONTROL.

   void   RelNew(void * templ)
Устанавливает (импортирует) ОТНОСИТЕЛЬНЫЕ (к текущим) координаты и размеры из
класса, на который указывает аргумент, а также производит позиционирование в
координаты (0,0).

   void	  at	(int l=(-1), int c=(-1))
Устанавливает новые координаты и позиционирует курсор. По умолчанию или при
аргументе <0 берется соответствующее текущее значение. Вызов at() без аргументов
приводит реальные координаты курсора к текущим координатам (что полезно при
печати через несколько объектов WINOUT и/или сочетанием с другими методами
печати).

   void	  pc	(char c);
Вывод знака (или управляющиего символа). Данный метод является базовым, т.к.
весь вывод других методов проходит через него.
  Символ '\t' обрабатывается внутренне и вызывает печать (рекурсивным вызовом)
требуемого, для достижения следующей восмисимвольной табуляции (или начала
следующей строки), количества пробелов. Символ '\n' (а также превышение
координаты колонки) вызывает обнуление текущей колонки, инкремент строки и
перепозиционирование курсора.
  Если символ не попадает в границы экрана, то он не печатается.

   char  *ps	(char * str, int n=0, int fField=0, int fSzz=0, uchar hattr=0);
  Печать первых n символов строки, если n=0 (и fField=0), печатается вся строка.
Флаг fField=1 указывает, что, если строка меньше n, то необходимо дополнить ее
пробелами (? табуляции).
  Флаг fSzz указывает на то, что в строке присутствуют управляющие
последовательности начинающиеся с '\0', а терминатором служит ДВОЙНОЙ нуль (или
неизвестное имя управляющей последовательности - символа после '\0').
hattr - байт атрибута для индикации горячей клавиши (код "\0&").
  Возвращаемое значение - поинтер на первый ненапечатанный символ (или
терминатор; для fSzz=1 - первый нуль терминатора) - используется внутренне,
при рекурсивном вызове.
  Управляющие последовательности:
   '\0a'+ строка, колонка     - установить новую позицию. Нежелательна при
                                лимитированной печати (n!=0 и/или fField=1),
				т.к. не оказывает влияния на счетчик символов.
   '\0t'+ колонка, символ     - печатать _символ_  до тех пор пока не будет
                                достигнута _колонка_ (даже если это будет на
				следующей строке). Игнорируется, если, требуемая
				колонка недостижима (больше размера окна).
				Также, пока, не поддерживается правильно при
				лимитированной печати.
   '\0i'+ цвет (0-15)	      - Установка цвета символа (ink)
   '\0p'+ цвет (0-7)          - Установка цвета фона (paper)
   '\0c'+ цвет символа, фона  - Установка атрибута из двух значений цветов
   '\0b'+ байт для 0pppiiii   - Установка атрибута из байта
   '\0&'+ символ              - Печать _символа_ с атрибутом hattr (аргумент
                                функции). Предназначена для выделения в
				подсказке буквы, соответствующей горячей
 				клавише.
   
   char  *pszz	(char * str, int n=0, int fField=0, uchar hattr);
Алиас для функции ps() c fSzz=1. Старое название - pf().

   char  *psfd  (char * str, int n);
Старая функция, а ныне - алиас для ps(str,n,1).

   void	  fill  (int type=FT_DOUBLE);
Функция заливающая окно пробелами с рамкой используя текущий аттрибут и
устанавливает курсор в (1,1) (или (0,0), если нет рамки) В
зависимости от типа type:
   FT_DOUBLE  - двойная рамка (по-умолчанию)
   FT_SINGLE  - одинарная рамка
   FT_NOFRAME - без рамки

Рамка строится внутри окна и поэтому, автоматически отменяется если размер
окна (по любому измерению) меньше трех символов.
  Рамка диалога строится без использования данной процедуры.

                        Другие функции
		      (не методы WINOUT)

   int    ts    (char * str, void * templ=0, int fSzz=0);
Трассировать строку, с подсчетом ее размеров (колонки и строки) в полях объекта
класса winTEMPL (см. WINOUT::New()) на который указывает _templ_. Размер в
колонках также используется в кчестве возвращаемого значения функции.
  По умолчанию, или если templ=0, объект выделяется динамически (и значение
размера в строках теряется).
  Флаг fSzz показывает, что в str указывает на строку с управляющими кодами
с нулевым префиксом и имеет терминатором двойной нуль.
  Процедура используется для определения размеров элемента уравления,
необходимого для размещения строки.

                      Параллельная печать
		      
  WINOUT не отслеживает текущего атрибута и не позиционирует курсор для печати
каждого символа, поэтому при переходе к другому объекту WINOUT (или переходу
к объекту WINOUT после печати иными методами) необходимо позаботится об
соответствии координат (вызвать at() без аргументов), атрибуте символа
(установить нужный атрибут).
