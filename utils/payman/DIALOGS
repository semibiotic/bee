7.08.2000 Новый аналог WINOUТ::pf называется "pszz" (скоро, также все вызовы
          WINOUT::psfd() будут исправлены на pszz() (или ps()) т.к. теперь они
	  обладают возможностями печати "поля")
7.08.2000 Поле sheme класса DIALOG с этого момента - ИНДЕКС цветовой схемы
2.08.2000 Добавлен элемент управления "разделитель"

                   Спецификация диалогового интерфейса

                          Описание диалогового окна

  Каждое диалоговое окно описывается:
   * объектом класса DIALOG
   * массивом элементов управления (класса CONTROL). Массив должен заканчиваться
     терминатором - классом CONTROL с нулевым поинтером на обработчик.
   * диалоговой функцией (если она используется)

  Вызов диалога - вызов метода DIALOG::Dialog() из объекта, описывающего
требуемый диалог (или равносильный вызов глобальной inline-функции Dialog() с
поинтером на объект).

  Возвращаемое значение диалога (если диалоговая процедура не возвращает иные
значения):
   * <0 - указывает на ошибку при попытке активировать диалог (на данный момент
     ею может быть только нехватка памяти - ID_MEMOUT)
   * =0 - (ID_CANCEL) диалог (и действие, которое он предполагал) отменен
     пользователем (нажатием кнопки с таким полем id или нажатие Esc).
   * >0 - id нажатой кнопки или ID_OK (=1).

                               Диалоговое окно

  Диалоговое окно - область на экране с определенными и статическими (по
умолчанию размерами) и динамическими координатами. (По умолчанию) координаты
подстраиваются под размер терминала, окно занимало на экране требуемое режимом
выравнивания DIALOG::align (cм.) положение:

  * максимум
  * минимум
  * центрированной (по умолчанию)
  * центрированной по максимальной половине (или максимум)
  * центрированной по минимальной половине (или минимум)

по каждой из координат. Выравнивание диалога, также может взять на себя
диалоговая процедура (DA_PROC).

  Вокруг диалогового окна может быть построена рамка с тенью и центрированным
заголовком (если диалог имеет стиль DS_FRAMED). Размеры диалога соответствуют
ВНУТРЕННИМ размерам окна - без учета рамки.
  Для правильной работы диалог должен иметь хотя бы один элемент управления.

                         Элементы управления

  Элемент управления - ограниченная часть диалогового окна, с определенными и
статическими (по умолчанию) размерами и координатами (относительно окна).

  Элемент управления представляет собой активный объект, выполняющий действия:
   * перерисовать элемент (СA_DRAW)
     Перерисовывает элемент в пассивном виде
   * изобразить активность (клавиатурный фокус, CA_DRAWFOCUS)
     Перерисовывает элемент, его часть и/или устанавливает и определяет видимость
     курсора чтобы пользователь увидел элемент управления, находящийся в
     клавиатурном фокусе и его активное состояние.
   * обработать клавишу/событие (CA_EVENT)
     Обрабатывает клавишу передает ее дальше (возвращая ложное значение) по
     очереди диспетчера. Если состояние элемента управления изменилось, оставить
     уведомительное сообщение и перерисовать элемент управления активным.
   * установить состояние элемента управления (CA_SET и/или CA_SETTEXT)
     Устанавливает новое состояние элемента, оставляет уведомительное сообщение,
     перерисовывает объект пассивным. Не все элементы имеют такие действия,
     и состояние необходимо устанавливать вручную (с вызовом CA_DRAW)

  Каждый элемент может быть:
   * невидимым
   * отмененным

  На отмененный элемент управления нельзя установить фокуса (обычным порядком) и
поэтому отмененный элемент не учавствует в обработке клавиш/событий. Некоторые
типы элементов управления (статик, группа) должны быть отменены, потому, что они
не обрабатывают клавиш.
  Невидимый элемент просто не отображается при прорисовке диалога. Для правильной
работы невидимый элемент д.б. также отмененым.

  При активации диалога клавиатурный фокус (по умолчанию) устанавливается на
первый неотмененный элемент или устанавливается в -1 (в данный момент - в 0).

  По умолчанию, фокус передается на следующий или предыдущий (неотмененный)
элемент управления (с заворачиванием) по порядку в массиве *(DIALOG::ctrl) -
клавишами:
  * Tab (PgDn) - следующий
  * PgDn - предыдущий
а также, курсорными клавишами если диалог имеет стиль DS_ARROWS (для меню):
  * Down/Right - следующий
  * Up/Left - предыдущий

                      Элемент управления: Статический текст

  Статический текст служит для пояснения и написания заголовков для элементов
управления не имеющих таковых (напр. комбо). Статик обрабатывается процедурой
GenControl (поле type=CT_STATIC).
  Текст szzText печатается в границах элемента управления. На данный момент
ограничения не поддерживаются, заворачивание - посимвольное, циклическое.
Опять же, на данный момент для печати используется WINOUT::pszz(); что означает
подержку его управляющих кодов и требование ДВОЙНОГО терминатора (т.к. один '\0'
означает начало управляющего кода).
  Статический текст должен быть отмененым.

                          Элемент управления: Кнопка

  Кнопка - есть ничто иное, как место для подсветки. При попадании в фокус изображается
подсвеченной. Кнопка обрабатывается процедурой GenControl (type=CT_BUTTON).
  В кнопке, текст szzText печатается в границах элемента управления с дополнением
или обрезкой до ширины элемента управления (WINOUT::psfd(), управляющие коды не
поддерживаются). Высота кнопки подразумевается равной 1.
  При попадании в фокус кнопка перепечатывается подсвеченной.

  Если кнопка имеет подтип CT_MENULIKE, то она имеет флаг (checked/uncheched),
который изображается символом (в данный момент 'x') на выделяемом для этого левом
поле кнопки. Состояние кнопки отражает поле СONTROL::val.

  При нажатии Enter, когда в фокусе находится кнопка, по умолчанию, диалог
завершает работу, возвращая число из поля СONTROL::id кнопки (обработчик
возвращает RET_EXIT).
  Если диалоговая процедура обрабатывает уведомления (notify) элементов, то
вердикт RET_DONE (продолжить выполнение диалога) или RET_EXIT (завершить диалог
с возвратом id) выносит именно она.

                         Элемент управления: Чекбокс

  Чекбокс - элемент управления с двумя состояниями (как правило разрешающий или
запрещающий связанную с ним опцию). Обработчик чекбокса - GenControl
(type=CT_CHECKBOX). Инициализация не изменяет состояние чекбокса. 
  Чекбокс печатает свое состояние ([x] или [ ]) и пояснительный текст szzText.
(в данный момент - используюя WINOUT::pszz() - неограниченная длина, управляющие
коды, двойной терминатор).
  При попадании в фокус, чекбокс устанавливает курсор между "[]". Нажатие пробела
инвертирует состояние чекбоса.
  Действие СA_SET устанавливает состояние чекбокса из значения param (не
перепечатывая чекбокса). 
  Состояние чекбокса хранит поле CONTROL::val.

                    Элемент управления: Группа (рамка группы)

  Группа - рамка с заголовком для выделения нескольких связаных (тем или иным
признаком) элементов управления. Обработчик группы - GenControl (type=CT_GROUP).
  Размеры группы включают рамку. Заголовок szzText печатается в разрыве рамки.
  Группа должна предшествовать элементам, печатающимся внутри нее (иначе группа
их запечатает) и если диалоговая процедура перерисоваывает группу (напр. при
смене заголовка) то она также должна будет перестроить все входяшие в нее
элементы.
  Группа должна быть отмененной. Невидимую форму группы можно использовать в
качестве разделителя двух групп радиокнопок (если между оными не планируется ни
одного элемета управления).

                         Элемент управления: Разделитель
			 
  Разделитель - горизонтальная линия (символом рамки) от левого края диалога
до правого (для меню и др). Обработчик разделителя - GenControl
(type=CT_SEPARATOR).
  Обработчик игнорирует координаты и размеры, за исключением номера строки.
  Для правильной работы разделитель должен быть отмененным.

                         Элемент управления: Радиокнопка

  Радиокнопка - как и чекбокс, элемент с двумя состояниями, но в отличии от
чекбокса, радиокнопка может быть установлена лишь когда сброшены все остальные
радиокнопки ее группы, и сбрасывается при установке радиокнопки ее группы. Группа
в данном случае - радиокнопки, ограниченные другими элементами управления (в т.ч.
невидимая "группа") или границами массива элементов. Обработчик радиокнопки -
RadioBoxControl (type=0).
  При инициализации, диалог устанавливает первые радиокнопки в группах и
сбрасывает остальные. Диалоговая процедура может установить их требуемое
состояние в фазе action=PA_INITCTRL (но не используюя действия CA_SET, поскольку
оное ПЕЧАТАЕТ радиокнопку и ее группу).
  Радиокнопка ведет себя подобно чекбоксу, только флаг состояния печатается в
круглых или "угловых" скобках.
  Нажатие пробела устанавливает радиокнопку в фокусе и сбрасывает все радиокнопки
ее группы. Действие CA_SET делает то же, но требует индекс элемента в качастве
параметра. При изменении состояния радиокнопки, она и те кнопки, которых
коснулись изменения ПЕРЕПЕЧАТЫВАЮТСЯ (рекурсивными вызовами).
  
                       Элемент управления: Листбокс

  Листбокс - элемент управления, для выбора из некоторго конечного списка
символических строк. Итоговым значением, отражающим состояние листбокса является
индекс выбранного элемента.   Обработчик листбокса - ListBoxControl.
  Листбокс для хранения своего состояния использует следующие переменные (в
объекте класса CONTROL или LISTBOX):
  int   CONTROL::limit - ограничение на размер списка (в штуках)
  ulong CONTROL::val   - текущий выбраный элемент
 (void* CONTROL::mem   - поинтер на объект LISTBOX) 
  int   LISTBOX::pcs   - количество элементов в списке
  int   LISTBOX::disp  - номер первого отображаемого элемента списка
  char**LISTBOX::array - поинтер на список
  Объект класса LISTBOX являестся внешним (СS_EXTERN) или создается и
инициализируется диалогом.
  Если в листбоксе не определен стиль CS_EXTLST (внешний список), то диалог
выделяет память под список (массив указателей на строки), размером определенным
CONTROL::limit следом за классом LISTBOX и устанавливает на него поинтер array
(при стиле CS_EXTERN, состояние CS_EXTLST игнорируется).
  Если диалог выделил память под класс LISTBOX, то он производит его
инициализацию
  * устанавливает указатель на список (или сбрасывает в 0 при
    внешнем (CS_EXTLST) списке - его должна установить диалоговая процедура)
  * pcs=0
  Также, вне зависимости от стиля, диалог устанавливает выбранным первый
элемент (val=0, disp=0).  
  Диалоговая процедура может провести свои установки в фазе PA_INITCTRL.

  Листбокс строит рамку с заголовком szzText в разрыве и видимый участок списка
с выделением текущего элемента (иным атрибутом).

  При попадании в фокус, листбокс печатает подсветку на выбранном элементе
списка. Клавиши стрелок перемещают выбор по списку.
  Действие CA_SET устанавливает выбранным элемент, с номером переданным в
param.
  Действия для работы со списком, вроде CA_ADDITEM и CA_KILLIST на данный
момент отсутствуют.

                   Элемент управления: Комбо-бокс

  Комбо-бокс - элемент управления для редактирования текста и итоговым его
значением является строка. Для элементов со списком или счетом также
используется поле CONTROL::val - индекс выбранного элемента или значение числа,
но это поле действительно, только если после его изменения не выполнялось
операций над текстом, поэтому значение этого поля можно трактовать как
результат только в комбо с атрибутом CBT_READONLY. Обработчик комбо - 
ComboBoxControl, поле CONTROL::type определяет тип и атрибуты комбо.
  Типы комбо (type&CBT_MASK)
  CBT_EDIT   - простой элемент для редактирования текста 
  CBT_COUNT  - элемент для ввода чисел с возможностью его инкремента и
       декремента (стрелками верх и вниз).
  CBT_SIMPLE - элемент редактирования текста с возможностью подстановки
       строк из списка (стрелками вверх и вниз). После подстановки
       восстановление исходного текста невозможно.
  CBT_DROPDN - аналогичен CBT_SIMPLE, но при выборе строки для подстановки
       выпадает список, аналогичный листбоксу (т.к. используется та же
       процедура). Нажатие Enter в этом списке осуществляет подстановку
       выбранной строк, Esc отменяет подстановку (текст в комбо не изменяется)
  Аттрибуты комбо:
  CBT_NUMERIC  - разрешается ввод только цифр
  CBT_FLOAT    - разрешается ввод только цифр и точки. Для типа CBT_COUNT это
      также означает дробное значение
  CBT_SIGNED   - (в дополнение с CBT_NUMERIC или CBT_FLOAT) разрешает ввод
      минуса. Для типа CBT_COUNT это также означает возможность использования
      отрицательных значений.
  CBT_READONLY - запрещает редактирование текста. Это превращает комбо типов,
      отличных от CBT_EDIT в подобие листбокса.

  Комбо, хранит свое состояние в следующих переменных:
   int    CONTROL::limit   - предельный размер текста (буфер-1)
   char*  CONTROL::szzText - (значение int) предельный размер списка (в штуках)
   uchar  CONTROL::val     - индекс последнего выбора или число после инкремента
                             или декремента (ulong, long или float)
  (void*  CONTROL::mem     - поинтер на объект COMBOX)
   int	   COMBOX::len     - длина строки в буфере
   int     COMBOX::pos     - позиция в буфере 
   int     COMBOX::disp    - первая печатная позиция буфера   
   char*   COMBOX::buff    - поинтер на буфер
   float   COMBOX::step    - шаг инкремента/декремента
   int     COMBOX::h       - высота выпадающего списка 
   int     COMBOX::w       - (не используется)
   LISTBOX COMBOX::lst     - объект LISTBOX, для хранения данных о списке

  При инициализации диалог выделяет память под объект COMBOX (если элемент не
определен CS_EXTERN), буфер строки (размером limit+1) (если не определен 
CS_EXTBUF), буфер под список, размер которого (int) хранит поле szzText (если
не определен CS_EXTLST). При определенном CS_EXTERN, состояния битов CS_EXTBUF
и CS_EXTLST игнорируются.
  Если диалог выделяет память под СOMBOX, то инициализирует поля:
  * buff - устанавливает на выделенный буфер (или 0, если CS_EXTBUF, 
          диалоговая процедура должна установить это поле)
  * h=6 (список в четыре строки)
  * w=0 
  * lst.pcs=0
  * lst.array - устанавливается на выделенную память (или 0, если CS_EXTLST,
          диалоговая процедура должна установить это поле)
  А также, вне зависимости от стиля
  * len=0
  * pos=0
  * disp=0
  * step - устанавливается в единицу (для CBT_FLOAT - 0.1)
  * lst.disp=0
    
  Комбо печатает в выделенном пространстве видимую часть буфера, для комбо с
выпадающим списком также печатается горячая дроп-зона мыши. Комбо не может
быть многострочным.
  При попадании в фокус комбо изображает курсор (он появляется даже в read-only
комбо). Клавиши управления курсором и редактирования текста:
    вправо  (Ctrl-S) - перемещение по строке
    влево   (Ctrl-D) - перемещение по строке
    Home             - в начало строки
    End              - в конец строки
    BS               - Удалить предыдущий символ
    Del     (Ctrl-G) - Удалить символ в позиции курсора
    Ctrl-Y           - Стереть строку
    Ctrl-K           - Удалить остаток строки (после курсора) 
    Ctrl-A           - Перейти к предыдущему слову
    Ctrl-F           - Перейти к следующему слову
    Ctrl-BS (Ctrl-W) - Удалить предыдущее (или текущее) слово
    Ctrl-T           - Удалить следующее (или текущее) слово
  Клавиши вверх и вниз управляют подстановкой из списка (комбо со списком) или
инкрементируют/декрементируют числовое значение (числовое комбо). При инкременте
декременте, строка в буфере преобразуется в число (ulong, long или float; посему
нечисловая строка будет приравнена к нулю), производится его изменение, запись
в поле CONTROL::val, а затем обратное преобразование в строку буфера.

  Действие CA_SETTEXT копирует в буфер строку, поинтер на которую передается в
аргументе param. Запретить перерисовку можно добавив в действию CAS_NODRAW
  Действие СA_SET инициирует подстановку из списка (индекс - param) или
установку нового значения для числового комбо (значение соответствующего типа
передается как param). Запретить перерисовку можно добавив к Действию 
CAS_NODRAW.

   Выпадающий список реализован отдельным режимом обработки диалога (и
обработки листбокса). В этом режиме:
   * после прорисовки диалога поверх остального рисуется листбокс выпадающего
     списка (фиктивный листбокс) и фокус на нем (оригинальный фокус не
     отображается)
   * обработчик листбокса (в фиктивном режиме) перехватывает все клавиши,
     (за исключением изменения размеров терминала; клавиши не отдаются даже
     диалоговой процедуре на первичный перехват) и кроме стандартных клавиш
     листбокса обрабатываются Enter (подстановка и выход из фиктивного режима)
     и Esc (выход из фиктивного режима).
Данные фиктивного листбокса:
  * объект СONTROL для листбокса располагается последним в массиве элементов
    (терминатор - объект с нулевым CONTROL::proc). Перед включением режима
    фиктивного листбокса поля настраиваются (процедурой комбо) на текущее
    состояние комбо.
  * объект LISTBOX - находится в объекте COMBOX текущего комбо (правда в данный
    момент это не так ...).

                                  Память

  Для динамических данных диалог, диалоговая процедура и каждый элемент
управления используют память. По умолчанию память диалога, процедуры и элементов
управления выделяется одним фрагментом и делится (в порядке: диалог, диалоговая
процедура, первый элемент управления ... последний элемент управления).
  Память элементов управления, объявленных со стилями CS_EXTERN (полностью),
СS_EXTBUF и CS_EXTLST (частично - буфером и списком) может находится вне этого
поля памяти, но эта внешняя память не выделяется диалогом.
  Диалог подсчитывает размер памяти (записывает его в поле DIALOG::bytes),
выделяет память и сохраняет поинтер в поле DIALOG::mem. Если память не удается
выделить диалог возвращает ID_MEMOUT.
  Если диалог объявлен со стилем DS_STATIC, то память не выделяется (а
DIALOG::mem должен содержать действительное значение).
  Далее, диалог устанавливает указатели:
   * В классе DIALOG:
     * procmem (память диалоговой процедуры)
   * В элементах массива элементов управления, не имеющих стиля CS_EXTERN
     * CONTROL::mem
  
  Перед выделением памяти если поле СONTROL::bytes элементов управления равны
нулю, то они инициализируется значением по-умолчанию для типа плюс размеры
буферов.
  После выделения памяти (при инициализации данных элементов управления)
устанавливаются поинтеры на буферы. Если буферы (и только буферы) объявлены
внешними, то поинтеры на них обнуляются и должны быть установлены диалоговой
процедурой (во второй фазе пролога, action=PA_INITCTRL).

  При выходе память освобождается, поэтому в эпилоге (action=PA_EPILOGUE)
диалоговая процедура должна сохранить из нее все необходимые данные.

                                Процедуры

  Основные процедуры данной реализации:
   * int DIALOG::Dialog(ulong param)
       Основной метод диалога. Запускается при активации диалога и
     прекращает работу при его деактивации. Именно эта процедура занимается
     инициализацией, обработкой диалога по умолчанию и завершением диалога.
       Аргумент param не используется и прямо передается в диалоговую процедуру
     если она определена.
   * int DIALOG::(*proc)(DIALOG * th, int action, ulong param)
       AKA Диалоговая процедура. Процедура кустомизации поведения диалога.
     Данная процедура вызывается по методами диалога при наступленнии
     определенных условий (если вызовы при этих условиях разрешены стилем
     диалога, а также методом выравнивания).
       th     - поинтер на диалог (т.е. значение this)
       action - действие для которого процедура вызвана
       param  - параметр (используется для передаче параметра(-ов) для
                того или иного действия)
       Если эта процедура не используется DIALOG::proc=0.
   * ulong CONTROL::(*proc)(CONTROL*th,void*parent,int action,ulong param)
       AKA Обработчик элемента управления. Процедура выполняющая работу по
     прорисовке, отображении фокуса, обработке нажатий клавиш и специфических
     действий (установка состояния).
       th     - поинтер на объект CONTROL
       parent - поинтер на родительский диалог
       action - действие
       param  - параметр к действию

  Другие методы DIALOG:
   * Dispatch() - процедура диспетчерезации клавиши/события. клавишу по очереди
       просматривают:
         * сама Dispatch - перехват сообщения об изменении размеров терминала
         * диалоговая процедура (PA_PRIMARY) - перехват клавиш у фокуса и
               диалога
         * элемент управления в фокусе - клавиши элемента управления
         * диалог - клавиши перемещения фокуса, Enter, Esc
         * диалоговая процедура (PA_EVENT) - кустомные клавиши
       каждая процедура должна вернуть одно из следующих значений:
         RET_CONT   - передать клавишу дальше
         RET_DONE   - клавиша обработана
         RET_REDO   - клавиша обработана, обновить диалог и повторить 
                      диспечеризацию (напр. в keyLong занесли новое значение
                      "нажатой клавиши")
         RET_REDRAW - клавиша обработана, необходимо выравнять и перерисовать
                      диалог по-новой.
         RET_TERM   - клавиша обработана, необходимо выравнять (Arrange(); зоны
                      рабочего экрана), выравнить и перестроить диалог.
                      (при изменении размеров терминала)
+
+  Режимы перестройки диалога:
+  * элемент в фокусе - fDrawCur=1
+  * без изменения размеров, положения диалога (рабочий экран не обновляется)
+     - fDraw=1
+  * c изменением размеров или положения диалога без переразделения рабочего
+    экрана (рабочий экран перестраивается) - вернуть RET_REDRAW
+  * полное обновление экрана (для изменения размеров терминала)
+     - вернуть RET_TERM
+
         RET_EXIT   - клавиша обработана, завершить обработку диалога с
                      возвратом id текущего элемента (так делают кнопки)
         RET_DEFEXIT- клавиша обработана, завершить обработку диалога с
                      возвратом значения из поля DIALOGDATA::Focus (так делает
                      диспетчер диалога при нажатии Enter или Esc).
       кроме этого диспетчер проверяет значение СONTROL::notify и вызывает
       диалоговую процедуру, если оно не равно 0.

   * SetFocus(int n) - установить фокус:
      * перепечатывает старый элемент в пассивном состоянии
      * сообщает диалоговой процедуре о потере фокуса элементом
      * перепечатывает новый элемент в фокусе
      * сообщает диалоговой процедуре об установке фокуса
      * устанавливает новое значение DIALOGDATA::Focus

                        Процедура DIALOG::(*proc)()

  Диалоговая процедура (если она определена) вызывается в следующих случаях:

   * action=PA_PROLOGUE (если стиль DS_PROLOGED) - первая фаза инициализации.
      Вызывается до выделения памяти для элементов управления. В param
      передается аргумент переданый в диалог. Только в этой фазе процедура
      может скорректировать значения CONTROL::bytes. А в принципе в прологе
      можно изменять любые параметры диалога и его элементов управления
      находяшихся в статической памяти.
      В обычном случае возвращаемое значение должно быть равно RET_CONT,
      если оно будет равно RET_REDO то ожидание клавиши будет пропущено и
      в диспетчер будет послана последняя нажатая клавиша.
   * action=PA_INITCTRL (если стиль PA_PROLOGED) - вторая фаза инициализации
      Вызывается после выделения памяти и настройки элементов управления
      по-умолчанию. Процедура может скорректировать параметры диалога и элеметов
      управления в динамической памяти. Так процедура должна установить поинтеры
      внешних на внешние списки и буфера (CS_EXTLST, CS_EXTBUF) листбоксов и
      комбо, определенных без стиля CS_EXTERN (см.) Единственное, что не может
      диалоговая процедура сделать в этой фазе, так это установить фокуса (т.к.
      фокус устанавливается следом).
   * action=PA_ALIGN (если DIALOG::align=DA_PROC) выравнять диалог - т.е.
      определить координаты диалога, исходя из размеров экрана, диалога других
      произвольных факторов. Возвращаемое значение - флаг того, нужно ли
      дополнительно провести стандартное выравнивание (напр. процедура
      корректирует размеры диалога (исходя из размеров экрана) и возвращает
      ненуль чтобы выравнять диалог). Диалог выравнивается при начальной
      инициализации, а также всякий раз, когда меняются размеры терминала 
   * action=PA_PRIMEVENT (если стиль DS_PRIMARY) - упреждающая обработка клавиши
      (перехват клавиш элементов и диалога). Возвращаемое значение см. 
      Dispatch().
   * action=PA_EVENT (если стиль DS_EVENTS) - обработка клавиш (не обработаных
      элементом в фокусе или диалогом).
   * action=PA_NOTIFY (ecли стиль DS_NOTIFY) - обработка уведомления элемента
      управления. В param передается индекс элемента управления.
      На данный момент существуют следующие уведомления:
       * CN_FOCUS и CN_KILLFOCUS - сообщения об установке и потере элементом
         клавиатурного фокуса. Вызываются процедурой SetFocus().
       * CN_CLICKED - нажата кнопка или состояние элемента управления
         изменилось. На данный момент это уведомление обрабатываются только
         для элемента в фокусе, непосредственно после обработки клавиши.
         Обрабатывая это уведомление, диалоговая процедура должна вернуть
         вердикт вместо обработчика элемента управления. Если элемент не кнопка
         то это всегда RET_DONE. В случае же кнопки это RET_EXIT (для выхода
         из диалога - поведение по умолчанию) или RET_DONE (не выходить из
         диалога).

                        Процедура СONTROL::(*proc)()

 ulong CONTROL::(*proc)(CONTROL *th, void *parent, int action, ulong param);

  Базовые действия обработчика элемента управления:
   * action=CA_DRAW - отрисовать элемент управления (в пассивном состоянии)
   * action=CA_DRAWFOCUS - отрисовать (и/или установить курсор) необходимую
      часть элемента управления для отображения того, что он находится в
      клавиатурном фокусе.
   * action=CA_EVENT - обработать клавишу и перерисовать элемент управления.

                                Класс DIALOG   

class DIALOG
{   public:
    int		l;			
    int		c;
    int		h;
    int		w;
    ulong	style;
    int		align;
    int		scheme;
    char   *	title;
    int		(*proc)(DIALOG * th, int action, ulong param);
    int		procbytes;
    DIALOGDATA *mem;
    void    *   procmem;
    int		bytes;
    CONTROL *   ctrl;

    int		Dialog(ulong param);
    int		Dispatch();
    int		SetFocus(int n);
};

    int		l
    int		c
  Координаты диалога. По умолчанию (здесь и далее "по умолчанию" подразумевает
"поведение диалога по умолчанию" - процедура реализации диалога без определения
диалоговой процедуры), по умолчанию поля координат не требуют инициализации, т.к.
расчитываются перед построением диалога или при изменении размеров терминала, в
соответствии с режимами выравнивания (поле align).
  Диалоговая процедура (см. align) может полностью или частично (корректировка
размеров перед выравниванием).

    int		h;
    int		w;
  ВНУТРЕННИЕ (полезные) размеры диалога. По умолчанию - статические (требуют
инициализации).

    ulong	style;
Стиль диалога. Отдельные биты определяют:
    * Наличие рамки
      * DS_FRAMED - строить рамку с тенью
      * по умолчанию - без рамки
    * Тип памяти 
      * DS_STATIC - память выделена, поинтер DIALOG::mem действителен.
      * по умолчанию - размер памяти расчитывается и выделяется.
    * Обработка курсорных клавиш. 
      * DS_ARROWS - разрешить переключение между элементами стрелками (Up & Right
        - инкремент, Down & Left - декремент)). Предусмотрено для окон меню.
        ! При обработке клавиш приоритет элемента в фокусе выше, чем у диалога,
        ! посему, если в фокусе будет листбокс или комбо, эти клавиши не попадут
        ! в руки диспетчера диалога (хотя диалоговая процедура в силах это
        ! исправить, подменив код клавиши/события). 
      * по-умолчанию - курсорные клавиши игнорируются диспетчером диалога.
    * События, для обработки которых, вызывается Диалоговая процедура:
      * DS_PROLOGED - (пролог). Получение процедурой параметра(ов) вызова диалога
        (param) и инициализации структур диалога, в два вызова:
         * action=PA_PROLOGUE - произвольная настройка статических структур
           диалога и элементов управления. Вызывается до выделения памяти. 
             Пролог д/возвращать RET_CONT (=0), т.к. (для построения диалога без
           какой-либо обработки (для построения PullDown меню на экране))
           возвращаемое значение инициализирует переменную последнего вердикта
           диспетчера.  
    (++)     Если интересно - процедура возвращает RET_REDO - т.е. не ожидать
     ++    клавиши/события и после необходимой прорисовки диалога передать
     ++    управление прямо в диспетчер. В диспетчере "событие" перехватывается
     ++    (см. DS_PRIMARY) и возвращается вердикт "выйти из диалога" (RET_EXIT
     ++    или RET_DEFEXIT). (По такому вердикту обработка диалога завершается и
     ++    вызывается эпилог (action=PA_EPILOGUE, см. DS_EPILOGED)) Эпилог
     ++    восстанавливает элемент управления (первый пункт меню), стирая
    (++)   обозначение фокуса.
         * action=PA_INITCTRL - настройка динамических структур диалога и
           элементов управления (кроме установки клавиатурного фокуса, который
           устанавливается позже. Его можно установить в обработке PA_ALIGN (cм.
           ниже), с учетом характера PA_ALIGN)
      * DS_EVENTS - обработка клавиш/событий. С этим стилем, диалоговая процедура
        "подбирает" клавиши необработанные элементом в фокусе и диалогом
        (action=PA_EVENT). 
      * DS_PRIMARY - обработка клавиш/событий ПЕРЕД их обработкой элементом и
        диалогом - служит для перехвата этих клавиш. (action=PA_PRIMEVENT)
        Единственное событие, не перехватываемое таким образом - изменение
        размеров терминала (правда, еще - когда активен фиктивный листбокс -
        выпадающий список комбо, DS_PRIMARY игнорируется, как и все остальное,
        впрочем)
      * DS_NOTIFY - процедуре диалога сообщается об изменении состояния элементов
        управления диалогов (через CONTROL::notify). Это изменение состояния -
        СN_CLICKED и изменения фокуса - CN_FOCUS, CN_KILLFOCUS (в доработке).
      * DS_MODELESS - (параллельная работа) - взвешиваю, насколько оно нужно и 
        в каком варианте (прикидываю два).
          В любом случае, не будет реализовано, пока не разберусь с неожидающим
        вводом с клавиатуры.
      * DS_EPILOGED - (эпилог action=PA_EPILOGUE) Получает в качестве параметра
        возвращаемое значение, как его видит диалоговая процедура (ID кнопки).
        Возвращаемое значение эпилога возвращается в программу. Также эпилог,
        должен забрать необходимые данные из динамической памяти диалога (напр.
        буфер редактирования комбо), перед тем как эта память будет освобождена.

    int		align;
  Режим выравнивания диалога. Для выравнивания по умолчанию каждая из координат
может быть:
  * максимальной  (DA_DOWN и DA_RIGHT)
  * минимальной   (DA_UP и DA_LEFT)
  * отцентрированной (по умолчанию - DA_DEFAULT=0)
  * отцентрированной по максимальной половине (DA_HALFDOWN и DA_HALFRIGHT)
  * отцентрированной по минимальной половине  (DA_HALFUP и DA_HALFRIGHT)
Также диалог может выравниваться диалоговой процедурой (DA_PROC, action=PA_ALIGN)
в этом случае, процедура возвращает флаг, требуется ли после стандартное
выравнивание.

    int		scheme;
  Цветовая схема - индекс в массиве объектов SCHEME (cтруктура, описывающую
палитру диалога.

    char   *	title;
  Заголовок диалога, печатается в разрыве рамки по центру. Если заголовок не
помещается в рамку, то он сокращается (напр "#= Test D... =#" ).

    int		(*proc)(DIALOG * th, int action, ulong param);
  Поинтер на процедуру диалога. Если он равен 0, связанные с ним биты стиля
игнорируются. В процедуру передается поинтер на диалог (причем явно), число,
определяющее действие, для которого эта процедура вызывается, и параметр,
который может быть произвольным значением размером в двойное слово, структурой
(с общим размером в двойное слово) или поинтером.

    int		procbytes;
  Количество байт динамической памяти, требуемое процедурой диалога (д.б.
определено)

    DIALOGDATA *mem;
  Поинтер на память диалога (в начале которого располагаются данные самого
диалога, на которые поинтер и указывает, данные процедуры (если они требовались)
и данные элементов управления. Устанавливается диалогом, если он работает с
динамическим выделением памяти.
  Если диалог имеет стиль DS_STATIC, этот поинтер должен быть инициализирован и
указывать на память необходимого размера.

    void    *   procmem;
  Поинтер на данные диалоговой процедуры (размером procbytes). Устанавливается
диалогом.

    int		bytes;
  Общее количество памяти. Вычисляется диалогом из sizeof(DIALOGDATA), procbytes
и суммы CONTROL::bytes всех элементов.

    CONTROL *   ctrl;
  Поинтер на массив элементов управления. Должен быть инициализирован. 

    int		Dialog(ulong param);
  Главный метод диалога. Диалог активируется его прямым вызовом или вызовом
одноименной inline-функции int Dialog(DIALOG *th, ulong param).
  НЕ "ДИАЛОГОВАЯ ПРОЦЕДУРА"

    int		Dispatch();
  Диспетчер. Обрабатывает клавишу/событие keyLong и возвращает вердикт.

    int		SetFocus(int n);
Метод переключения клавиатурного фокуса, генерирует СN_FOCUS и СN_KILLFOCUS.

              Класс CONTROL

class CONTROL
{   public:
    int		l;
    int		c;
    int		h;
    int		w;
    ulong	style;
    ulong	id;
    ulong	(*proc)(CONTROL * th, void * parent, int action, ulong param);
    ulong	type;
    char    *   szzText;
    int		bytes;
    int		limit;
    void     *  mem;
    int		notify;
    ulong	val;
};

  Класс CONTROL описывает отдельный элемент управления в диалоге.


    int		l;
    int		c;
    int		h;
    int		w;
  Координаты (отн.) и размеры элемента управления. Должны быть инициализированы,
(если их размеры и/или координаты не пересчитываются диалоговой процедурой).

    ulong	style;
  Стиль элемента управления
   * CS_DISABLED - запрещенный элемент. на запрещенный элемент фокус не
     устанавливается.
   * CS_HIDDEN   - невидимый элемент, не отображается при прорисовке диалога. Для
     правильной работы невидимый элемент должен быть также запрещен.
   * CS_EXTERN   - элемент со статической (внешней) памятью. Диалог не выделяет
     памяти под элементы с этим стилем и не устанавливает поинтер mem на эту
     память. Установка этого стиля предполагает инициализацию поинтера mem.
   * CS_EXTBUF   - (для динамической памяти) указывает, что элемент (комбо) имеет
     внешний (статический) буфер и поинтер на буфер (см. описание комбо)
     инициализируется нулем.
   * CS_EXTLST	 - (для динамической памяти) указывает, что элемент (комбо или
     листбокс) имеет внешний (статический) список (т.е. массив поинтеров на
     строки) 
 
    ulong	id;
  Идентификатор (или иное значение, связаное с элеметом управления) По умолчанию,
диалог возвращает идентификатор нажатой кнопки.

    ulong	(*proc)(CONTROL * th, void * parent, int action, ulong param);
  Поинтер на обработчик элемента управления. Собственно, именно обработчик
определяет тип элемента и его поведение. Простые элементы управления (статик,
кнопка, чекбокс и группа) объединены в один обработчик GenControl. Конкретный
элемент определяет младший байт поля type.

    ulong	type;
  Тип элемента. Значение подтипа, отданое на откуп, обработчика.

    char    *   szzText;
  Поинтер на текст элемента (но не на буфер комбо !) - текст кнопки, статика,
чекбокса, заголовок листбокса и т.п. Строка с ДВОЙНЫМ ТЕРМИНАТОРОМ (на что и
указывает "szz"). Для комбо с списком в динамической памяти, эта переменная
содержит значение типа int - предельный размер списка (кол-во элементов).

    int		bytes;
  Размер памяти, требуемой для элемента управления. Хотя получается, что для
правильной работы он д.б. равен нулю (диалог сам вычисляет это поле, исходя из
типа элемента, и требований под список и/или буфер).

    int		limit;
  Предел элемента управления (размер строки для комбо, предельное кол-во
элементов списка для листбокса).

    void     *  mem;
  Указатель на память элемента управления, в зависимости от стиля элемента
управления на выделяемую (инициализируется диалогом) или статическую
(инициализируется программистом) память.

    int		notify;
  В этом поле обработчик оставляет сообщение для передачи в процедуру диалога.
Сама передача (PA_NOTIFY c индексом элемента в качестве параметра) выполняется
диспетчером фокуса (части метода DIALOG::Dispatch() ). Диалоговая процедура,
обрабатывающая данные сообщения должна обнулять это поле.

    ulong	val;
  Это поле отражает состояние элемента управления. Для чекбоксов, радиокнопок,
кнопок с подтипом CT_MENULIKE (элемент меню) это флаг "Checked", для листбокса -
выбранный элемент, для комбо со списком - последний ВЫБРАННЫЙ ИЗ СПИСКА элемент,
для count-комбо - число после последнего инкремента/декремента (если число набрать
руками, это поле не изменяется !). Для count-комбо поле val может быть
использовано для хранения значения типа (signed)long (CBT_SIGNED) или float
(CBT_FLOAT).

                             Класс DIALOGDATA

  Класс DIALOGDATA - динамические данные диалога. Поля:

   int      Focus    - индекс элемента управления в фокусе
   int      fDraw    - флаг обновления диалога без перестройки экрана
   int      fDrawCur - флаг обновления текущего элемента управления (фокус)
   int      fFList   - флаг режима фиктивного листбокса (см. комбо)
   LISTBOX  FList    - объект LISTBOX для фиктивного листбокса
   CONTROL *FLctrl   - объект CONTROL для фиктивного листбокса

                            Класс SCHEME

  Класс SCHEME - цветовая схема диалога. Каждое поле - атрибут для функции
bAttr() - цвет фона и символа (UNICON). Поля:
  frame     - цвета рамок
  title     - цвета заголовка (диалога)
  text  [2] - цвета текста, чекбокса, радиокнопки (отмененный/разрешенный)
  edit  [2] - цвета комбо (отмененный/разрешенный)
  button[3] - цвета кнопки (отмененная/разрешенная/подсвеченная(фокус))
  lst   [3] - цвета листбокса (невыбранный/выбранный/подсвеченный элемент
              списка)
