/* $RuOBSD: beeipf.c,v 1.5 2003/09/22 02:35:07 shadow Exp $ */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <syslog.h>
#include <unistd.h>

#include <bee.h>

/* Certain rule view

pass out [log] on tun0 [proto xxx] from 172.17.3.2/32 [port=n] to any [port=n]  xxxxxxxxx
         \___/    \__/ \_________/      \___________/ \______/    \_/ \______/  \_______/
pass out  log  on  if    rule_s    from     host       host_s  to dest dest_s     tail

pass in [log] on tun0  [proto xxx] from any [port=n] to 172.17.3.2/32 [port=n]  xxxxxxxxx
        \___/    \__/  \_________/      \_/ \______/    \___________/ \______/  \_______/
pass in  log  on  if     rule_s    from dest dest_s  to     host       host_s     tail

*/

char * word_pass= "pass";
char * word_in	= "in";
char * word_out	= "out";
char * logit	= NULL;
char * word_on	= "on";

char * rule_s    = NULL;
char * word_from = "from";
char * host      = NULL;    // obsolete
char * host_s    = NULL;
char * word_to   = "to";
char * dest      = "any";
char * dest_s    = NULL;
char * iface     = NULL;

char * tail      = NULL;

char * rsmark="#<beerules>";
char * rshead="# /////////////////////////////////////////////////\n"
              "# // Billing rules (generated by billing daemon) //\n"
              "# //   (all manual changes will be discarded)    //\n"
              "# /////////////////////////////////////////////////\n\n";
char * rsepilog="\n# /////////////////////////////////////////////////\n";
char * ipf_line="/sbin/ipf -Fa -f /var/bee/ipf.rules.effective";
char * srchosts="/var/bee/allowed.inet";
char * srcrules="/etc/ipf.rules";
char * dstrules="/var/bee/ipf.rules.effective";
char   namebuf[32]; 

char   buf[256];
char   hostname[80];


extern char * optarg;
void usage(int rc);

int main (int argc, char ** argv)
{
   char * ruleset;
   void * tmp;
   char * ptr;
   char * str;
   int    len;
   int    onerule = 0;
   FILE * f    = NULL;
   FILE * fout = NULL;
   char   c;

/*
    TODO:
 s   1. Redefine default filter source file (/etc/ipf.rules)
 t   2. Redefine default filter target file (/var/bee/ipf.rules.effecive)
 d   3. Redefine destination host (any)
 i   4. Redefine target interface (tun0)
 r   5. Redefine resource name (inet)
 f   6. Redefine allowed filename (/var/bee/allowed.inet)
 P   7. Redefine dest_s (NULL)
 p   8. Redefine host_s (NULL)
 m   9. Redefine filter file rsmark (#<beerules>)
 S  10. Redefine rule_s (NULL)
 R  11. Reverse in & out
 l  12. Redefine log mark(NULL)
 o  13. One rule only (to destination)
*/   

#define OPTS "s:t:d:i:r:f:P:p:m:S:Rl:oT:"

   while ((c = getopt(argc, argv, OPTS)) != -1)
   {  switch (c)
      {
      case 's':
         srcrules=optarg;
         break;
      case 't':
         dstrules=optarg;
         break;
      case 'd':
         dest=optarg;
         break;	 
      case 'i':
         iface   = optarg;
         break;	 
      case 'r':
         snprintf(namebuf, sizeof(namebuf),"/var/bee/allowed.%s", optarg); 
         srchosts=namebuf;    
         break;	 
      case 'f':
         srchosts=optarg;
         break;	 
      case 'P':
         dest_s=optarg;    // ??
         break;	 
      case 'p':
         host_s=optarg;    // ??
         break;	 
      case 'S':
         rule_s=optarg;    // ??
         break;	 
      case 'm':
         rsmark=optarg;
         break;
      case 'R':
         tmp      = word_out;
         word_out = word_in;
         word_in  =(char*)tmp;
         break;
      case 'l':
	 logit = optarg;
         break;
      case 'o':
         onerule = 1;
         break;
      case 'T':
	 tail = optarg;
         break;
      default:
         usage(-1);
      }
   }

// Generate rules block

   ruleset=(char *)calloc(1, strlen(rshead)+1);
   if (ruleset==NULL) 
   {  syslog(LOG_ERR, "calloc(): %m");
      exit (-1);
   }
   strcpy(ruleset, rshead);

   if (strcmp(srchosts, "-") != 0)
   {  f=fopen(srchosts, "r");
      if (f==NULL) 
      {  syslog(LOG_ERR, "open(%s): %m", srchosts);
         exit (-1);
      }
   }
   else f=stdin;

   while(1)
   {  if (fgets(hostname, sizeof(hostname), f) == NULL) break;

      ptr = hostname;
      str = next_token(&ptr, " \t\n");
      if (str == NULL) continue;
      host = str;

      len = sprintf(buf, "%s %s %s%s%s%s%s%s%s%s%s %s %s%s%s %s%s%s%s%s\n",
	word_pass,
	word_out,
	logit ? logit:"", logit ? " ":"",
        iface ? word_on:"",
        iface ? " ":"", 
        iface ? iface:"", iface ? " ":"",   
        rule_s ? rule_s:"", rule_s ? " ":"",
        word_from,
        host,
        host_s ? host_s:"", host_s ? " ":"",
        word_to,
        dest,
        dest_s ? " ":"", dest_s ? dest_s:"",
        tail ? " ":"", tail ? tail:"");

      if (! onerule)
      {  sprintf(buf+len, "%s %s %s%s%s%s%s%s%s%s%s %s %s%s%s %s%s%s%s%s\n",
	   word_pass,
	   word_in,
	   logit ? logit:"", logit ? " ":"",
           iface ? word_on:"",
           iface ? " ":"", 
           iface ? iface:"", iface ? " ":"",  
           rule_s ? rule_s:"", rule_s ? " ":"",
           word_from,
           dest,
           dest_s ? dest_s:"", dest_s ? " ":"",
           word_to,
           host,
           host_s ? " ":"", host_s ? host_s:"",
           tail ? " ":"", tail ? tail:"");
      } 
      len=strlen(ruleset)+strlen(buf)+1;
      tmp=realloc(ruleset, len);
      if (tmp==NULL) exit (-1);
      ruleset=(char *)tmp;
      strncat(ruleset, buf, len);
   }
   if (f != stdin) fclose(f);

   len = strlen(ruleset) + strlen(rsepilog) + 1;
   tmp = realloc(ruleset, len);
   if (tmp==NULL)
   {  syslog(LOG_ERR, "realloc(): %m");
      exit (-1);
   }
   ruleset=(char *)tmp;
   strcat(ruleset, rsepilog);

   if (strcmp(srcrules, "-") != 0)
   {  f=fopen(srcrules, "r");
      if (f==NULL)
      {  syslog(LOG_ERR, "fopen(%s): %m", srcrules);
         exit (-1);
      }
   }
   else f = stdin;	

   if (strcmp(dstrules, "-") != 0)
   {  fout=fopen(dstrules, "w");
      if (fout == NULL)
      {  syslog(LOG_ERR, "fopen(%s): %m", dstrules);
         exit (-1);
      }
   }
   else fout = stdout;	

   while (1)
   {  if (fgets(buf, sizeof(buf), f) == NULL) break;
      fprintf(fout, "%s", buf);
      if (strncmp(buf, rsmark, strlen(rsmark))==0 &&
          ruleset != NULL)
      {  fprintf(fout, "%s", ruleset);
         free(ruleset);
         ruleset=NULL;
      }
   }
   if (ruleset != NULL)
   {  fprintf(fout, "%s", ruleset);
      free(ruleset);
      ruleset=NULL;
   }
   if (f != stdin)     fclose(f);
   if (fout != stdout) fclose(fout);

   return 0; 
}

void usage(int rc)
{
    fprintf(stderr,"%s",
 "beeipf - IPF rules generator\n"
 "Usage: beeipf [<switches>]\n" 
 "s - filter source file (default - /etc/ipf.rules)\n"
 "t - filter target file (default - /var/bee/ipf.rules.effecive)\n"
 "d - destination host   (default - \"any\")\n"
 "i - target interface   (default - none)\n"
 "r - resource name      (default - inet)\n"
 "f - hostlist filename  (default - /var/bee/allowed.inet)\n"
 "P - destination suffix (default - \"\")\n"
 "p - source suffix      (default - \"\")\n"
 "m - filter file mark   (default - \"#<beerules>\")\n"
 "S - rule suffix        (default - \"\")\n"
 "R - swap in & out      (default - no swap)\n"
 "l - word before \"on\"   (default - \"\")\n"
 "o - only one rule      (default - two rules)\n"
 "T - rule tail          (default - none)\n");
    exit(rc);
}
