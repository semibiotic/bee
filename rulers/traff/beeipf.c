/* $RuOBSD$ */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <syslog.h>
#include <unistd.h>


/* Certain rule view

pass out on tun0 [proto xxx] from 172.17.3.2/32 [port=n] to any [port=n]
\______________/ \_________/      \___________/ \______/    \_/ \______/
    rulefrom       rule_s    from    host        host_s  to dest  dest_s

pass in on tun0  [proto xxx] from any [port=n] to 172.17.3.2/32 [port=n]
\______________/ \_________/      \_/ \______/    \___________/ \_______/
    ruleto         rule_s    from dest dest_s  to     host       host_s

*/

char * rulefrom ="pass out on";
char * rule_s   =NULL;
char * word_from="from";
char * host     =NULL;
char * host_s   =NULL;
char * word_to  ="to";
char * dest     ="any";
char * dest_s   =NULL;
char * ruleto  ="pass in on";
char * iface   ="tun0";

char * rsmark="#<beerules>";
char * rshead="# /////////////////////////////////////////////////\n"
              "# // Billing rules (generated by billing daemon) //\n"
              "# //   (all manual changes will be discarded)    //\n"
              "# /////////////////////////////////////////////////\n\n";
char * rsepilog="\n# /////////////////////////////////////////////////\n";
char * ipf_line="/sbin/ipf -Fa -f /var/bee/ipf.rules.effective";
char * srchosts="/var/bee/allowed.inet";
char * srcrules="/etc/ipf.rules";
char * dstrules="/var/bee/ipf.rules.effective";
char   namebuf[32]; 

extern char * optarg;
void usage(int rc);

int main (int argc, char ** argv)
{  char   buf[256];
   char * ruleset;
   char * rulefile;
   char * hostsfile;
   void * tmp;
   char * ptr;
   char * str;
   int    len, bytes;
   FILE * f=NULL;
   char   c;

/*
    TODO:
 s   1. Redefine default filter source file (/etc/ipf.rules)
 t   2. Redefine default filter target file (/var/bee/ipf.rules.effecive)
 d   3. Redefine destination host (any)
 i   4. Redefine target interface (tun0)
 r   5. Redefine resource name (inet)
 f   6. Redefine allowed filename (/var/bee/allowed.inet)
 P   7. Redefine dest_s (NULL)
 p   8. Redefine host_s (NULL)
 m   9. Redefine filter file rsmark (#<beerules>)
 S  10. Redefine rule_s (NULL)
 R  11. Reverse in & out
*/   
#define OPTS "s:t:d:i:r:f:P:p:m:S:R"
   while ((c = getopt(argc, argv, OPTS)) != -1)
   {  switch (c)
      {
      case 's':
         srcrules=optarg;
         break;
      case 't':
         dstrules=optarg;
         break;
      case 'd':
         dest=optarg;
         break;	 
      case 'i':
         iface=optarg;
         break;	 
      case 'r':
         snprintf(namebuf, sizeof(namebuf),"/var/bee/allowed.%s", optarg); 
         srchosts=namebuf;    
         break;	 
      case 'f':
         srchosts=optarg;
         break;	 
      case 'P':
         dest_s=optarg;    // ??
         break;	 
      case 'p':
         host_s=optarg;    // ??
         break;	 
      case 'S':
         rule_s=optarg;    // ??
         break;	 
      case 'm':
         rsmark=optarg;
         break;
      case 'R':
         tmp=rulefrom;
         rulefrom=ruleto;
         ruleto=(char*)tmp;
         break;	 
      default:
         usage(-1);
      }
   }

   ruleset=(char *)calloc(1, strlen(rshead)+1);
   if (ruleset==NULL) 
   {  syslog(LOG_ERR, "calloc(): %m");
      exit (-1);
   }
   strcpy(ruleset, rshead);

   f=fopen(srchosts, "r");
   if (f==NULL) 
   {  syslog(LOG_ERR, "open(%s): %m", srchosts);
      exit (-1);
   }
   if (ioctl(fileno(f), FIONREAD, &bytes)<0)
   {  syslog(LOG_ERR, "ioctl(%s): %m", srchosts);
      exit (-1);
   }
   hostsfile=calloc(1, bytes+1);
   if (hostsfile==NULL)
   {  syslog(LOG_ERR, "calloc(): %m");
      exit (-1);
   }
   if (fread(hostsfile, 1, bytes, f) != bytes)
   {  syslog(LOG_ERR, "fread(): %m");
      exit (-1);
   }
   fclose(f);
   ptr=hostsfile;

   while(1)
   {  do
      {  str=strsep(&ptr, " \n\t");
         if (str==NULL) break;
      } while (*str=='\0');
      if (str==NULL) break;
      host=str;
      sprintf(buf, "%s %s %s%s%s %s %s%s%s %s%s%s\n"
                   "%s %s %s%s%s %s %s%s%s %s%s%s\n",
	rulefrom,
        iface, 
        rule_s ? rule_s:"", rule_s ? " ":"",
        word_from,
        host,
        host_s ? host_s:"", host_s ? " ":"",
        word_to,
        dest,
        dest_s ? " ":"", dest_s ? dest_s:"",
	ruleto,
        iface, 
        rule_s ? rule_s:"", rule_s ? " ":"",
        word_from,
        dest,
        dest_s ? dest_s:"", dest_s ? " ":"",
        word_to,
        host,
        host_s ? " ":"", host_s ? host_s:"");
      len=strlen(ruleset)+strlen(buf)+1;
      tmp=realloc(ruleset, len);
      if (tmp==NULL) exit (-1);
      ruleset=(char *)tmp;
      strncat(ruleset, buf, len);
   }
   free(hostsfile);
   len=strlen(ruleset)+strlen(rsepilog)+1;
   tmp=realloc(ruleset, len);
   if (tmp==NULL)
   {  syslog(LOG_ERR, "realloc(): %m");
      exit (-1);
   }
   ruleset=(char *)tmp;
   strcat(ruleset, rsepilog);

   f=fopen(srcrules, "r");
   if (f==NULL)
   {  syslog(LOG_ERR, "fopen(%s): %m", srcrules);
      exit (-1);
   }
   if (ioctl(fileno(f), FIONREAD, &bytes)<0)
   {  syslog(LOG_ERR, "ioctl(): %m");
      exit (-1);
   }
   len+=bytes;
   rulefile=calloc(1, len +1 /* for fgets() */);
   if (rulefile==NULL)
   {  syslog(LOG_ERR, "calloc(): %m");
      exit (-1);
   }
 
   ptr=rulefile;
   bytes=len+1;
   while(1)
   {  if (bytes<=0)
      {  syslog(LOG_ERR, "buffer overrun()");
         exit (-1);
      }
      if (fgets(ptr, bytes, f)==NULL) break;
      if (strncmp(ptr, rsmark, strlen(rsmark))==0 && ruleset != NULL)
      {  bytes-=strlen(ptr);
         ptr  +=strlen(ptr);
         strcpy(ptr, ruleset);
         free(ruleset);
         ruleset=NULL;
      }

      bytes-=strlen(ptr);
      ptr  +=strlen(ptr);
   }
   if (ruleset != NULL)
   {  strcpy(ptr, ruleset);
      free(ruleset);
      ruleset=NULL;
   }
   fclose(f);
   f=fopen(dstrules, "w");
   if (f == NULL)
   {  syslog(LOG_ERR, "fopen(%s): %m", dstrules);
      exit (-1);
   }
   if (fwrite(rulefile, 1, strlen(rulefile), f) != strlen(rulefile))
   {  syslog(LOG_ERR, "fwrite(): %m");
      exit (-1);
   }
   fclose(f);
   return 0; 
}

void usage(int rc)
{
    fprintf(stderr,"%s",
 "beeipf - IPF rules generator\n"
 "Usage: beeipf [<switches>]\n" 
 "s - filter source file (default - /etc/ipf.rules)\n"
 "t - filter target file (default - /var/bee/ipf.rules.effecive)\n"
 "d - destination host   (default - \"any\")\n"
 "i - target interface   (default - tun0)\n"
 "r - resource name      (default - inet)\n"
 "f - hostlist filename  (default - /var/bee/allowed.inet)\n"
 "P - destination suffix (default - \"\")\n"
 "p - source suffix      (default - \"\")\n"
 "m - filter file mark   (default - \"#<beerules>\")\n"
 "S - rule suffix        (default - \"\")\n");
    exit(rc);
}
